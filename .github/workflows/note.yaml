name: Note Workflow

on:
  workflow_dispatch:
    inputs:
      theme:
        description: '記事テーマ'
        required: true
        type: string
      target:
        description: '想定読者（ペルソナ）'
        required: true
        type: string
      message:
        description: '読者に伝えたい核メッセージ'
        required: true
        type: string
      cta:
        description: '読後のアクション（CTA）'
        required: true
        type: string
      tags:
        description: 'カンマ区切りタグ（任意）'
        required: false
        default: ''
        type: string
      is_public:
        description: '公開(true)/下書き(false)'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']
      dry_run:
        description: '投稿をスキップ（生成のみ）'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']

permissions:
  contents: read

env:
  TZ: Asia/Tokyo
  # ここだけでモデルを定義（各job/stepへ自動継承）
  CLAUDE_MODEL: claude-3-5-sonnet-20241022

jobs:
  research:
    name: Research (CCSDK WebSearch/WebFetch)
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
    outputs:
      research_b64: ${{ steps.collect.outputs.research_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Preflight check (keys & model)
        run: |
          set -euo pipefail
          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            echo "::error::ANTHROPIC_API_KEY が未設定です。Settings→Secrets→Actions に追加してください。"
            exit 2
          fi
          if [ -z "${CLAUDE_MODEL:-}" ]; then
            echo "::error::CLAUDE_MODEL が空です。トップレベル env に設定してください。"
            exit 2
          fi
          echo "Keys/Model OK"

      - name: Install Claude Agent SDK (pinned)
        run: |
          set -euo pipefail
          npm init -y >/dev/null 2>&1 || true
          npm i @anthropic-ai/claude-agent-sdk@0.5.1 @anthropic-ai/sdk@0.24.0

      - name: Research with Claude Agent SDK (robust)
        run: |
          set -euo pipefail
          mkdir -p .note-artifacts
          cat > research.mjs <<'EOF'
          import { createClient } from "@anthropic-ai/sdk";
          import fs from "fs/promises";

          const THEME = process.env.THEME || '';
          const TARGET = process.env.TARGET || '';
          const MODEL = process.env.CLAUDE_MODEL || '';
          const today = new Date().toISOString().slice(0,10);

          // 下位SDK疎通確認
          const base = createClient({ apiKey: process.env.ANTHROPIC_API_KEY });
          try {
            await base.messages.create({
              model: MODEL, max_tokens: 64,
              messages: [{ role: "user", content: "ping" }],
            });
          } catch (e) {
            console.error("SDK connectivity failed:", e?.message ?? e);
            process.exit(3);
          }

          // Agent SDK 本処理
          try {
            const { Agent } = await import("@anthropic-ai/claude-agent-sdk");
            const agent = new Agent({
              apiKey: process.env.ANTHROPIC_API_KEY,
              model: MODEL,
            });

            const sys = [
              'あなたは一次情報の要約に長けた上級リサーチャーです。',
              '出典は本文にMarkdownリンクで埋め込むこと。',
              '不明点は「前提と仮定」で明示して続行すること。'
            ].join('\n');

            const prompt = `以下条件でnote用の下調べレポートを作成してください（見出し・箇条書き含む）。
            - テーマ: ${THEME}
            - 想定読者: ${TARGET}
            - 目的: 後続ライティングに使う一次情報ダイジェスト
            - 現在日付: ${today}
            可能な限り一次情報を優先し、本文内にMarkdownリンクで出典を埋め込んでください。`;

            const res = await agent.run(prompt, { system: sys });
            const text = String(res?.output ?? '').trim();

            await fs.mkdir('.note-artifacts', { recursive: true });
            await fs.writeFile('.note-artifacts/research.md', text);
            console.log("Research generated: .note-artifacts/research.md");
            process.exit(0);
          } catch (err) {
            console.error("Claude Agent SDK error:", err?.message ?? err);
            process.exit(10);
          }
          EOF
          node --unhandled-rejections=strict research.mjs

      - name: Collect research
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/research.md 2>/dev/null || base64 .note-artifacts/research.md)
          echo "research_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload research artifacts
        uses: actions/upload-artifact@v4
        with:
          name: research-artifacts
          path: .note-artifacts/research.md

  write:
    name: Write (Claude Sonnet 4.0)
    needs: research
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA: ${{ github.event.inputs.cta }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      draft_json_b64: ${{ steps.collect.outputs.draft_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install AI SDK
        run: |
          npm init -y >/dev/null 2>&1 || true
          npm i ai @anthropic-ai/claude-agent-sdk@0.6.1 @anthropic-ai/sdk@0.24.0

      - name: Restore research
        env:
          RESEARCH_B64: ${{ needs.research.outputs.research_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$RESEARCH_B64" | base64 -d > .note-artifacts/research.md || echo "$RESEARCH_B64" | base64 --decode > .note-artifacts/research.md

      - name: Generate draft (title/body/tags)
        run: |
          cat > write.mjs <<'EOF'
          import { generateText } from 'ai';
          import { anthropic } from '@anthropic-ai/claude-agent-sdk';
          import fs from 'fs';

          const theme=process.env.THEME||'';
          const target=process.env.TARGET||'';
          const message=process.env.MESSAGE||'';
          const cta=process.env.CTA||'';
          const inputTags=(process.env.INPUT_TAGS||'').split(',').map(s=>s.trim()).filter(Boolean);
          const researchReport=fs.readFileSync('.note-artifacts/research.md','utf8');
          const modelName=process.env.CLAUDE_MODEL;

          function extractJsonFlexible(raw){
            const t=(raw||'').trim().replace(/\u200B/g,'');
            try{ return JSON.parse(t); }catch{}
            const m=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/); if(m&&m[1]){ try{ return JSON.parse(m[1].trim()); }catch{} }
            const f=t.indexOf('{'), l=t.lastIndexOf('}'); if(f!==-1&&l!==-1&&l>f){ try{ return JSON.parse(t.slice(f,l+1)); }catch{} }
            return null;
          }
          async function repairJson(raw){
            const sys='入力から {"title":string,"draftBody":string,"tags":string[]} のJSONのみ返答。';
            const {text}=await generateText({model:anthropic(modelName),system:sys,prompt:String(raw),temperature:0,maxTokens:8000});
            return extractJsonFlexible(text||'');
          }
          function sanitizeTitle(s){
            let t=String(s||'').trim();
            t=t.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'').replace(/^#+\s*/,'');
            t=t.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'').replace(/^`+|`+$/g,'').replace(/^json$/i,'').trim();
            if(!t) t='タイトル（自動生成）'; return t;
          }
          function deriveTitleFromText(text){
            const lines=(text||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
            const first=lines.find(l=>!/^```/.test(l))||lines[0]||''; return sanitizeTitle(first);
          }

          const sysWrite='note.com向け長文記事の生成。JSON {title,draftBody,tags[]} で返答。draftBodyは6000〜9000文字目安。';
          const prompt=[`{テーマ}: ${theme}`,`{ペルソナ}: ${target}`,`{リサーチ}: ${researchReport}`,`{メッセージ}: ${message}`,`{CTA}: ${cta}`].join('\n');

          const {text}=await generateText({model:anthropic(modelName),system:sysWrite,prompt,temperature:0.7,maxTokens:30000});
          let obj=extractJsonFlexible(text||'')||await repairJson(text||'');
          let title, draftBody, tags;
          if(obj){ title=sanitizeTitle(obj.title); draftBody=String(obj.draftBody||'').trim(); tags=Array.isArray(obj.tags)?obj.tags.map(String):[] }
          if(!title||!draftBody){ title=deriveTitleFromText(text||''); const lines=(text||'').split(/\r?\n/); draftBody=lines.slice(1).join('\n').trim()||(text||''); tags=[] }
          if(inputTags.length){ tags=Array.from(new Set([...(tags||[]),...inputTags])); }
          fs.writeFileSync('.note-artifacts/draft.json',JSON.stringify({title,draftBody,tags},null,2));
          EOF
          node write.mjs

      - name: Collect draft
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/draft.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/draft.json 2>/dev/null || base64 .note-artifacts/draft.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "draft_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload draft artifact
        uses: actions/upload-artifact@v4
        with:
          name: draft-artifact
          path: .note-artifacts/draft.json

  factcheck:
    name: Fact-check (Tavily)
    needs: write
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
      TITLE: ${{ needs.write.outputs.title }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      final_b64: ${{ steps.collect.outputs.final_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install AI SDK
        run: |
          npm init -y >/dev/null 2>&1 || true
          npm i ai @anthropic-ai/claude-agent-sdk@0.6.1 @anthropic-ai/sdk@0.24.0

      - name: Restore draft json
        env:
          DRAFT_JSON_B64: ${{ needs.write.outputs.draft_json_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$DRAFT_JSON_B64" | base64 -d > .note-artifacts/draft.json || echo "$DRAFT_JSON_B64" | base64 --decode > .note-artifacts/draft.json

      - name: Fact-check with Tavily
        run: |
          cat > factcheck.mjs <<'EOF'
          import { generateText } from 'ai';
          import { anthropic } from '@anthropic-ai/claude-agent-sdk';
          import fs from 'fs';

          const draft=JSON.parse(fs.readFileSync('.note-artifacts/draft.json','utf8'));
          const modelName=process.env.CLAUDE_MODEL;
          const TAVILY_API_KEY=process.env.TAVILY_API_KEY||'';
          if(!TAVILY_API_KEY){ console.error('TAVILY_API_KEY is not set'); process.exit(1); }

          function extractJsonFlexible(raw){
            const t=(raw||'').trim().replace(/\u200B/g,'');
            try{ return JSON.parse(t); }catch{}
            const fence=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/); if(fence&&fence[1]){ try{ return JSON.parse(fence[1].trim()); }catch{} }
            let f=t.indexOf('{'), l=t.lastIndexOf('}'); if(f!==-1&&l!==-1&&l>f){ try{ return JSON.parse(t.slice(f,l+1)); }catch{} }
            f=t.indexOf('['); l=t.lastIndexOf(']'); if(f!==-1&&l!==-1&&l>f){ try{ return JSON.parse(t.slice(f,l+1)); }catch{} }
            return null;
          }
          function stripCodeFence(s){
            const t=String(s||'').trim();
            const m=t.match(/^```[a-zA-Z0-9_-]*\s*([\s\S]*?)\s*```\s*$/); if(m&&m[1]) return m[1].trim();
            return t;
          }

          async function proposeQueries(body){
            const sys='あなたは事実検証の専門家です。入力本文から検証が必要な固有名詞・数値・主張を抽出し、Tavily検索用に日本語の検索クエリを最大10件の配列で返してください。出力はJSON配列のみ。';
            const { text } = await generateText({ model: anthropic(modelName), system: sys, prompt: String(body), temperature: 0, maxTokens: 2000 });
            const arr = extractJsonFlexible(text||'');
            return Array.isArray(arr) ? arr.map(String).filter(Boolean).slice(0,10) : [];
          }

          async function tavilySearch(q){
            const res = await fetch('https://api.tavily.com/search', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ api_key: TAVILY_API_KEY, query: q, search_depth: 'advanced', max_results: 5, include_answer: true })
            });
            if(!res.ok){ return { query:q, results:[], answer:null }; }
            const json = await res.json().catch(()=>({}));
            return { query:q, results: Array.isArray(json.results)? json.results: [], answer: json.answer || null };
          }

          function formatEvidence(items){
            const lines = [];
            for(const it of items){
              lines.push(`### 検索: ${it.query}`);
              if(it.answer){ lines.push(`要約: ${it.answer}`); }
              for(const r of it.results||[]){
                const t = (r.title||'').toString();
                const u = (r.url||'').toString();
                const c = (r.content||'').toString().slice(0,500);
                lines.push(`- [${t}](${u})\n  ${c}`);
              }
              lines.push('');
            }
            return lines.join('\n');
          }

          async function main(){
            const queries = await proposeQueries(draft.draftBody||'');
            const results = [];
            for(const q of queries){ results.push(await tavilySearch(q)); }
            const evidence = formatEvidence(results);
            const sys=[
              'あなたは事実検証の専門家です。以下の原稿（note下書き）に対し、提供エビデンスに基づき誤情報修正・一次情報リンク付与を行い、修正後本文のみ返答。',
              '文体・構成は可能な限り維持。必要なら末尾に参考文献セクション追記。'
            ].join('\n');
            const prompt = ['## 原稿', String(draft.draftBody||''), '', '## エビデンス', evidence].join('\n\n');
            const { text } = await generateText({ model: anthropic(modelName), system: sys, prompt, temperature: 0.3, maxTokens: 30000 });
            let body = stripCodeFence(text||'');
            let title = process.env.TITLE || draft.title || '';
            let tags = Array.isArray(draft.tags)? draft.tags: [];
            const obj = extractJsonFlexible(body);
            if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
              if (obj.title) title = String(obj.title);
              const candidates = [obj.body, obj.draftBody, obj.content, obj.text];
              const chosen = candidates.find(v=>typeof v==='string' && v.trim());
              if (chosen) body = String(chosen);
              if (Array.isArray(obj.tags)) tags = obj.tags.map(String);
            }
            body = stripCodeFence(body);
            const out = { title, body, tags };
            fs.writeFileSync('.note-artifacts/final.json', JSON.stringify(out,null,2));
          }

          await main();
          EOF
          node factcheck.mjs

      - name: Upload final artifact
        uses: actions/upload-artifact@v4
        with:
          name: final-artifact
          path: .note-artifacts/final.json

      - name: Collect final
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/final.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/final.json 2>/dev/null || base64 .note-artifacts/final.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "final_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  post:
    name: Post to note.com (Playwright)
    needs: factcheck
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
      START_URL: https://editor.note.com/new
    outputs:
      final_url: ${{ steps.publish.outputs.published_url || steps.publish.outputs.draft_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install Playwright
        run: |
          npm init -y >/dev/null 2>&1 || true
          npm i playwright marked
          npx playwright install --with-deps chromium | cat

      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_JSON" || (echo "ERROR: NOTE_STORAGE_STATE_JSON secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          echo "$STATE_JSON" > "$RUNNER_TEMP/note-state.json"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> $GITHUB_OUTPUT

      - name: Ensure jq (post)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Restore final
        id: draft
        env:
          FINAL_B64: ${{ needs.factcheck.outputs.final_b64 }}
        run: |
          test -n "$FINAL_B64" || { echo "final_b64 output is empty"; exit 1; }
          echo "$FINAL_B64" | base64 -d > final.json || echo "$FINAL_B64" | base64 --decode > final.json
          echo "TITLE=$(jq -r .title final.json)" >> $GITHUB_OUTPUT
          echo "TAGS=$(jq -r '.tags | join(", ")' final.json)" >> $GITHUB_OUTPUT

      - name: Publish via Playwright (draft or public)
        id: publish
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS: ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
          IS_PUBLIC: ${{ env.IS_PUBLIC }}
          START_URL: ${{ env.START_URL }}
        run: |
          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import { marked } from 'marked';
          import fs from 'fs';
          import os from 'os';
          import path from 'path';

          function nowStr(){ const d=new Date(); const z=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}_${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}`; }

          const STATE_PATH=process.env.STATE_PATH;
          const START_URL=process.env.START_URL||'https://editor.note.com/new';
          const rawTitle=process.env.TITLE||'';
          const rawFinal=JSON.parse(fs.readFileSync('final.json','utf8'));
          const rawBody=String(rawFinal.body||'');
          const TAGS=process.env.TAGS||'';
          const IS_PUBLIC=String(process.env.IS_PUBLIC||'false')==='true';

          if(!fs.existsSync(STATE_PATH)){ console.error('storageState not found:', STATE_PATH); process.exit(1); }

          const ssDir=path.join(os.tmpdir(),'note-screenshots');
          fs.mkdirSync(ssDir,{recursive:true});
          const SS_PATH=path.join(ssDir,`note-post-${nowStr()}.png`);

          function sanitizeTitle(t){
            let s=String(t||'').trim();
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'' );
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'').replace(/^`+|`+$/g,'').replace(/^json$/i,'').trim();
            if (/^[\{\}\[\]\(\)\s]*$/.test(s)) s='';
            if(!s) s='タイトル（自動生成）';
            return s;
          }
          function htmlFromMarkdown(md){
            return String(marked.parse(md, { gfm:true, breaks:false, mangle:false, headerIds:false }) || '');
          }
          async function insertHTML(page, locator, html){
            await locator.click();
            await locator.evaluate((el, html) => {
              el.focus();
              const sel = window.getSelection();
              const range = document.createRange();
              range.selectNodeContents(el);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
              document.execCommand('insertHTML', false, html);
            }, html);
          }

          let TITLE=sanitizeTitle(rawTitle);
          const htmlAll = htmlFromMarkdown(rawBody);

          let browser, context, page;
          try{
            browser = await chromium.launch({ headless: true, args: ['--lang=ja-JP'] });
            context = await browser.newContext({ storageState: STATE_PATH, locale: 'ja-JP' });
            page = await context.newPage();
            page.setDefaultTimeout(180000);

            await page.goto(START_URL, { waitUntil: 'domcontentloaded' });
            await page.waitForSelector('textarea[placeholder*="タイトル"]');
            await page.fill('textarea[placeholder*="タイトル"]', TITLE);

            const bodyBox = page.locator('div[contenteditable="true"][role="textbox"]').first();
            await bodyBox.waitFor({ state: 'visible' });
            await insertHTML(page, bodyBox, htmlAll);
            await page.waitForTimeout(200);

            if(!IS_PUBLIC){
              const saveBtn = page.locator('button:has-text("下書き保存"), [aria-label*="下書き保存"]').first();
              if(await saveBtn.isVisible() && await saveBtn.isEnabled()){ await saveBtn.click().catch(()=>{}); }
              await page.screenshot({ path: SS_PATH, fullPage: true });
              console.log('DRAFT_URL=' + page.url());
              console.log('SCREENSHOT=' + SS_PATH);
              process.exit(0);
            }

            const proceed = page.locator('button:has-text("公開に進む")').first();
            await proceed.waitFor({ state: 'visible' });
            for (let i=0;i<20;i++){ if (await proceed.isEnabled()) break; await page.waitForTimeout(100); }
            await proceed.click({ force: true });

            await Promise.race([
              page.waitForURL(/\/publish/i).catch(() => {}),
              page.locator('button:has-text("投稿する")').first().waitFor({ state: 'visible' }).catch(() => {}),
            ]);

            const tags=(TAGS||'').split(/[\n,]/).map(s=>s.trim()).filter(Boolean);
            if(tags.length){
              let tagInput=page.locator('input[placeholder*="ハッシュタグ"]');
              if(!(await tagInput.count())) tagInput=page.locator('input[role="combobox"]').first();
              await tagInput.waitFor({ state: 'visible' });
              for(const t of tags){ await tagInput.click(); await tagInput.fill(t); await page.keyboard.press('Enter'); await page.waitForTimeout(120); }
            }

            const publishBtn = page.locator('button:has-text("投稿する")').first();
            await publishBtn.waitFor({ state: 'visible' });
            for (let i=0;i<20;i++){ if (await publishBtn.isEnabled()) break; await page.waitForTimeout(100); }
            await publishBtn.click({ force: true });

            await Promise.race([
              page.waitForURL(u => !/\/publish/i.test(typeof u === 'string' ? u : u.toString()), { timeout: 20000 }).catch(() => {}),
              page.locator('text=投稿しました').first().waitFor({ timeout: 8000 }).catch(() => {}),
              page.waitForTimeout(5000),
            ]);

            await page.screenshot({ path: SS_PATH, fullPage: true });
            console.log('PUBLISHED_URL=' + page.url());
            console.log('SCREENSHOT=' + SS_PATH);
          } finally {
            try{ await page?.close(); }catch{}
            try{ await context?.close(); }catch{}
            try{ await browser?.close(); }catch{}
          }
          EOF
          node post.mjs | tee post.log
          url=$(grep '^PUBLISHED_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          draft=$(grep '^DRAFT_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          shot=$(grep '^SCREENSHOT=' post.log | tail -n1 | cut -d'=' -f2-)
          if [ -n "$url" ]; then echo "published_url=$url" >> $GITHUB_OUTPUT; fi
          if [ -n "$draft" ]; then echo "draft_url=$draft" >> $GITHUB_OUTPUT; fi
          if [ -n "$shot" ]; then echo "screenshot=$shot" >> $GITHUB_OUTPUT; fi

      - name: Upload screenshot (if any)
        if: ${{ steps.publish.outputs.screenshot != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: note-screenshot
          path: ${{ steps.publish.outputs.screenshot }}
